---
import { getCollection } from 'astro:content';
import Section from './Section.astro';
import SectionTitle from './SectionTitle.astro';
import ServiceCard from './ServiceCard.astro';
import { grid_classes } from './_grid';
import classNames from 'classnames';

/* 320px => Height of cards in starting position. 4 cards x 80px of indentation */
const styles = [
  `bg-[#5362DBE5] lg:delay-[400ms] lg:top-[calc(100vh-320px)]`,
  `bg-[#424C6DE5] lg:delay-300 lg:top-[calc(100vh-320px+80px)]`,
  `bg-[#3C3843E5] lg:delay-200 lg:top-[calc(100vh-320px+80px+80px)]`,
  `bg-[#1E1A1AE5] lg:delay-100 lg:top-[calc(100vh-320px+80px+80px+80px)]`,
];

const servicesCollection = await getCollection('services');

const services = [];

for (const service of servicesCollection) {
  const data = await service.render();

  services[service.data.idx - 1] = {
    content: data.Content,
    title: service.data.title,
    img: {
      path: service.data.imgPath,
      alt: service.data.imgAlt,
    },
  };
}
---

<Section
  className='w-full !overflow-visible lg:!px-0'
  contentClassName={classNames(grid_classes, 'lg:pt-12')}
>
  <SectionTitle
    idx='services-title'
    className='lg:px-7 col-span-6 lg:col-start-2 lg:col-span-10'
  >
    Our Services
  </SectionTitle>
  <div id='services-wrapper' class='col-span-6 md:col-span-12'>
    <div
      id='animation-wrapper'
      class='max-lg:grid max-md:grid-cols-6 max-lg:grid-cols-12 max-lg:gap-7 lg:h-screen lg:overflow-hidden lg:sticky lg:top-0'
    >
      {
        services.map((value, idx) => (
          <ServiceCard
            idx={idx + 1}
            title={value.title}
            content={value.content}
            styles={styles[idx]}
            imgPath={value.img.path}
            imgAlt={value.img.alt}
            onDark={idx === 1}
          />
        ))
      }
    </div>
  </div>
</Section>
<script is:inline>
  const wrapperWidth = window.innerWidth;

  if (wrapperWidth >= 1024) {
    const valuesWrapper = document.getElementById('values-wrapper');

    const servicesWrapper = document.getElementById('services-wrapper');
    const animationWrapper = document.getElementById('animation-wrapper');
    const servicesTitle = document.getElementById('services-title');
    const cards = document.querySelectorAll('[data-show]');

    const screenHeight = window.innerHeight;
    const cardsIndentation = 80;
    // Threshold value for amount of px we need to enter into animation
    // field before elements start moving around.
    const scrollThreshold = 1000;

    const getCardsAnimationThresholds = () => {
      let animationThresholds = [];
      cards.forEach((_, i) => {
        const prev = cards[i - 1];
        const startHeight = cards.length * cardsIndentation;
        if (prev) {
          const prevThresholds = animationThresholds[i - 1];

          animationThresholds.push({
            startAt: prevThresholds.endAt,
            distance: prevThresholds.distance + cardsIndentation,
            endAt:
              prevThresholds.endAt +
              (prevThresholds.distance + cardsIndentation),
          });
        } else {
          animationThresholds.push({
            startAt: 0,
            distance: screenHeight - startHeight,
            endAt: screenHeight - startHeight,
          });
        }
      });

      return {
        animationThresholds,
        animationFieldHeight:
          animationThresholds[animationThresholds.length - 1].endAt,
      };
    };
    const { animationThresholds, animationFieldHeight } =
      getCardsAnimationThresholds();

    const firstCardAnimationRange = animationThresholds[0].distance;

    const servicesWrapperHeight =
      animationFieldHeight + screenHeight + 2 * scrollThreshold;

    servicesWrapper.style.transform = `translateY(${-firstCardAnimationRange}px)`;
    servicesWrapper.style.height = `${servicesWrapperHeight}px`;

    animationWrapper.style.top = `${firstCardAnimationRange}px`;

    servicesWrapper.parentElement.style.maxHeight = `${servicesWrapperHeight - (firstCardAnimationRange - 180)}px`;

    let lastScrollTopPos = 0;

    const setupInitPositions = () => {
      const servicesWrapperBoundingRect =
        servicesWrapper.getBoundingClientRect();
      const fromTop = servicesWrapperBoundingRect.top * -1;

      // Do nothing if top edge of animated section is below viewport. Leave elements at bottom position
      if (servicesWrapperBoundingRect.top > screenHeight) {
        return;
      }

      animationThresholds.forEach((pos, i) => {
        const cardToPosition = cards[i];

        if (!cardToPosition) {
          return;
        }

        // if viewport is below end range of animation set element to top position
        if (fromTop > pos.startAt && fromTop > pos.endAt) {
          cardToPosition.style.transform = `translateY(-${pos.distance}px)`;
          return;
        }

        // if viewport is in range of animation set element to correct position
        if (fromTop >= pos.startAt && fromTop < pos.endAt) {
          cardToPosition.style.transform = `translateY(${pos.startAt - fromTop}px)`;
        }
      });
    };

    // Delay init position setup in case there is a smooth scroll behavior at init page render
    setTimeout(() => {
      setupInitPositions();
    }, 200);

    const animateSurroundingElems = (fromTop) => {
      if (fromTop >= 0 && fromTop <= servicesWrapperHeight / 2) {
        valuesWrapper.style.transform = `translateY(${fromTop}px)`;
        servicesTitle.style.transform = `translateY(${fromTop}px)`;
      } else {
        valuesWrapper.style.transform = `translateY(0px)`;
        servicesTitle.style.transform = `translateY(0px)`;
      }
    };

    const animateCards = (fromTop, isScrollDown, fadeInOutThreshold) => {
      // Start animation 200px before in case there is a fast scroll up so elements can catch that up and adjust
      // End animation screenHeight value after in case of fast scroll down (in this case click and smooth scroll to book session section)
      if (
        fromTop < fadeInOutThreshold ||
        fromTop > animationFieldHeight + screenHeight
      ) {
        return;
      }

      if (isScrollDown) {
        cards.forEach((el, i) => {
          const startPos = animationThresholds[i].startAt;
          const endPos = animationThresholds[i].endAt;
          if (fromTop > fadeInOutThreshold) {
            el.setAttribute('data-show', 'true');
          }

          if (startPos <= fromTop && endPos > fromTop) {
            el.style.transform = `translateY(${startPos - fromTop}px)`;
          }
          // Adjust element top position after animation range in case we didn't catch last few px.
          // This can be the case while fast scrolling
          if (startPos <= fromTop && endPos < fromTop) {
            el.style.transform = `translateY(${-animationThresholds[i].distance}px)`;
          }
        });
      } else {
        cards.forEach((el, i) => {
          const startPos = animationThresholds[i].startAt;
          const endPos = animationThresholds[i].endAt;
          if (fromTop < fadeInOutThreshold + cardsIndentation) {
            el.setAttribute('data-show', '');
          }

          if (startPos <= fromTop && animationThresholds[i].endAt > fromTop) {
            const startAt = endPos - startPos;
            el.style.transform = `translateY(-${startAt - (endPos - fromTop)}px)`;
          }
          // Adjust element bottom position after animation range in case we didn't catch last few px.
          // This can be the case while fast scrolling
          if (endPos > fromTop && startPos > fromTop) {
            el.style.transform = `translateY(0px)`;
          }
        });
      }
    };

    const handleAnimationOnScroll = () => {
      const currentScrollTop = window.scrollY;
      const servicesWrapperBoundingRect =
        servicesWrapper.getBoundingClientRect();
      const fromTop = servicesWrapperBoundingRect.top * -1;
      const isScrollDown = lastScrollTopPos < currentScrollTop;
      const fadeInOutThreshold = firstCardAnimationRange - screenHeight - 1000;

      animateSurroundingElems(fromTop);
      animateCards(fromTop - 1000, isScrollDown, fadeInOutThreshold);

      lastScrollTopPos = currentScrollTop <= 0 ? 0 : currentScrollTop;
    };

    window.addEventListener('scroll', handleAnimationOnScroll);
  }
</script>
