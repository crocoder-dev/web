---
import { getCollection } from 'astro:content';
import Section from './Section.astro';
import SectionTitle from './SectionTitle.astro';
import ServiceCard from './ServiceCard.astro';
import { grid_classes } from './_grid';
import classNames from 'classnames';

/* 320px => Height of cards in starting position. 4 cards x 80px of indentation */
const styles = [
  `bg-[#5362DBE5] lg:delay-[400ms] lg:top-[calc(100vh-320px)]`,
  `bg-[#424C6DE5] lg:delay-300 lg:top-[calc(100vh-320px+80px)]`,
  `bg-[#3C3843E5] lg:delay-200 lg:top-[calc(100vh-320px+80px+80px)]`,
  `bg-[#1E1A1AE5] lg:delay-100 lg:top-[calc(100vh-320px+80px+80px+80px)]`,
];

const servicesCollection = await getCollection('services');

const services = [];

for (const service of servicesCollection) {
  const data = await service.render();

  services[service.data.idx - 1] = {
    content: data.Content,
    title: service.data.title,
    img: {
      path: service.data.imgPath,
      alt: service.data.imgAlt,
    },
  };
}
---

<Section
  className='w-full !overflow-visible lg:!px-0'
  contentClassName={classNames(grid_classes, 'lg:pt-12')}
>
  <SectionTitle
    idx='services-title'
    className='lg:px-7 col-span-6 lg:col-start-2 lg:col-span-10'
  >
    Our Services
  </SectionTitle>
  <div id='services-wrapper' class='col-span-6 md:col-span-12'>
    <div
      id='animation-wrapper'
      class='max-lg:grid max-md:grid-cols-6 max-lg:grid-cols-12 max-lg:gap-7 lg:h-screen lg:overflow-hidden lg:sticky lg:top-0'
    >
      {
        services.map((value, idx) => (
          <ServiceCard
            idx={idx + 1}
            title={value.title}
            content={value.content}
            styles={styles[idx]}
            imgPath={value.img.path}
            imgAlt={value.img.alt}
            onDark={idx === 1}
          />
        ))
      }
    </div>
  </div>
</Section>
<script is:inline>
  let handleAnimationOnScroll = null;

  function addCardsAnimation() {
    const wrapperWidth = window.innerWidth;
    const valuesWrapper = document.getElementById('values-wrapper');

    const servicesWrapper = document.getElementById('services-wrapper');
    const animationWrapper = document.getElementById('animation-wrapper');
    const servicesTitle = document.getElementById('services-title');
    const cards = document.querySelectorAll('[data-show]');

    if (handleAnimationOnScroll) {
      window.removeEventListener('scroll', handleAnimationOnScroll);
      console.log('Scroll listener removed');
    }

    if (wrapperWidth >= 1024) {

      const screenHeight = window.innerHeight;
      const cardsIndentation = 80;
      // Threshold value for amount of px we need to enter into animation
      // field before elements start moving around.
      const scrollThreshold = 1000;

      const getCardsAnimationThresholds = () => {
        let animationThresholds = [];
        cards.forEach((card, i) => {
          const prev = cards[i - 1];
          const startHeight = cards.length * cardsIndentation;

          if (prev) {
            const prevThresholds = animationThresholds[i - 1];
            const cardRect = card.getBoundingClientRect();
            
            animationThresholds.push({
              startAt: prevThresholds.endAt + cardRect.height/2,
              distance: prevThresholds.distance + cardsIndentation,
              endAt:
                prevThresholds.endAt +
                (prevThresholds.distance + cardsIndentation),
            });
          } else {
            animationThresholds.push({
              startAt: 0,
              distance: screenHeight - startHeight,
              endAt: screenHeight - startHeight,
            });
          }
        });

        return {
          animationThresholds,
          animationFieldHeight:
            animationThresholds[animationThresholds.length - 1].endAt,
        };
      };
      const { animationThresholds, animationFieldHeight } =
        getCardsAnimationThresholds();

      const firstCardAnimationRange = animationThresholds[0].distance;

      const servicesWrapperHeight =
        animationFieldHeight + screenHeight + 2 * scrollThreshold;

      servicesWrapper.style.transform = `translateY(${-firstCardAnimationRange}px)`;
      servicesWrapper.style.height = `${servicesWrapperHeight}px`;

      animationWrapper.style.top = `${firstCardAnimationRange}px`;

      servicesWrapper.parentElement.style.maxHeight = `${servicesWrapperHeight - (firstCardAnimationRange - 180)}px`;

      let lastScrollTopPos = 0;

      const setupInitPositions = () => {
        const servicesWrapperBoundingRect =
          servicesWrapper.getBoundingClientRect();
        const fromTop = servicesWrapperBoundingRect.top * -1;

        // Do nothing if top edge of animated section is below viewport. Leave elements at bottom position
        if (servicesWrapperBoundingRect.top > screenHeight) {
          return;
        }

        animationThresholds.forEach((pos, i) => {
          const cardToPosition = cards[i];

          if (!cardToPosition) {
            return;
          }

          // if viewport is below end range of animation set element to top position
          if (fromTop > pos.startAt && fromTop > pos.endAt) {
            cardToPosition.style.transform = `translateY(-${pos.distance}px)`;
            return;
          }

          // if viewport is in range of animation set element to correct position
          if (fromTop >= pos.startAt && fromTop < pos.endAt) {
            cardToPosition.style.transform = `translateY(${pos.startAt - fromTop}px)`;
          }
        });
      };

      // Delay init position setup in case there is a smooth scroll behavior at init page render
      setTimeout(() => {
        setupInitPositions();
      }, 200);

      const animateSurroundingElems = (fromTop) => {
        const startHeight = cards.length * cardsIndentation;
        const paddings = 160;
        const valuesWrapperTop = valuesWrapper.offsetHeight - screenHeight + startHeight + paddings + servicesTitle.offsetHeight;
        const servicesTitleTop = screenHeight - startHeight - 48 - servicesTitle.offsetHeight;
        if (fromTop >= 0 && fromTop <= servicesWrapperHeight / 2) {
          valuesWrapper.style.position = 'sticky';
          valuesWrapper.style.top = `-${valuesWrapperTop}px`
          servicesTitle.style.position = 'sticky';
          servicesTitle.style.top = `${servicesTitleTop}px`;
        } else {
          // valuesWrapper.style.position = 'static';
          // servicesTitle.style.position = 'static';
        }
      };

      const animateCards = (fromTop, isScrollDown, fadeInOutThreshold) => {
        // Start animation 200px before in case there is a fast scroll up so elements can catch that up and adjust
        // End animation screenHeight value after in case of fast scroll down (in this case click and smooth scroll to book session section)
        if (
          fromTop < fadeInOutThreshold ||
          fromTop > animationFieldHeight + screenHeight
        ) {
          return;
        }

        if (isScrollDown) {
          cards.forEach((el, i) => {
            const startPos = animationThresholds[i].startAt;
            const endPos = animationThresholds[i].endAt;

            if (fromTop > fadeInOutThreshold) {
              el.setAttribute('data-show', 'true');
            }

            if (startPos <= fromTop && endPos > fromTop) {
              el.style.transform = `translateY(${startPos - fromTop}px)`;
            }
            // Adjust element top position after animation range in case we didn't catch last few px.
            // This can be the case while fast scrolling
            if (startPos <= fromTop && endPos < fromTop) {
              el.style.transform = `translateY(${-animationThresholds[i].distance}px)`;
            }
          });
        } else {
          cards.forEach((el, i) => {
            const startPos = animationThresholds[i].startAt;
            const endPos = animationThresholds[i].endAt;
            if (fromTop < fadeInOutThreshold + cardsIndentation) {
              el.setAttribute('data-show', '');
            }

            if (startPos <= fromTop && animationThresholds[i].endAt > fromTop) {
              const startAt = endPos - startPos;
              el.style.transform = `translateY(-${startAt - (endPos - fromTop)}px)`;
            }
            // Adjust element bottom position after animation range in case we didn't catch last few px.
            // This can be the case while fast scrolling
            if (endPos > fromTop && startPos > fromTop) {
              el.style.transform = `translateY(0px)`;
            }
          });
        }
      };

      handleAnimationOnScroll = () => {
        const currentScrollTop = window.scrollY;
        const servicesWrapperBoundingRect =
          servicesWrapper.getBoundingClientRect();
        const fromTop = servicesWrapperBoundingRect.top * -1;
        const isScrollDown = lastScrollTopPos < currentScrollTop;
        const fadeInOutThreshold = firstCardAnimationRange - screenHeight - 1000;

        // add 200px to prevent jump when fast scrolling
        animateSurroundingElems(fromTop + 200);
        animateCards(fromTop - 1000, isScrollDown, fadeInOutThreshold);

        lastScrollTopPos = currentScrollTop <= 0 ? 0 : currentScrollTop;
      };

      window.addEventListener('scroll', handleAnimationOnScroll);
    } else {
      valuesWrapper.style.position = 'static';
      servicesTitle.style.position = 'static';
      servicesWrapper.style.height = 'unset';
      servicesWrapper.style.transform = 'unset';
      cards.forEach(el => {
        el.style.transform = 'unset'
      })
    }
  }

  addCardsAnimation();

  window.addEventListener('resize', addCardsAnimation);
</script>
